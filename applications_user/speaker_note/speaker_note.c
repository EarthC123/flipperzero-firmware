#include "speaker_note.h"
#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <input/input.h>
#include <stdlib.h>

/* generated by fbt from .png files in images folder */
#include <speaker_note_icons.h>

static FuriMessageQueue *event_queue;
static FuriMutex        *model_mutex;
static ViewPort         *view_port;
static Gui              *gui;

static note_info note[] = {
    {.name_sharp="C0 ", .name_flat="C0 ", .frequency=C0},  {.name_sharp="Cs0", .name_flat="Db0", .frequency=Db0}, {.name_sharp="D0 ", .name_flat="D0 ", D0},  {.name_sharp="Ds0",  .name_flat="Eb0", .frequency=Eb0}, {.name_sharp="E0 ", .name_flat="E0 ", E0},  {.name_sharp="F0 ", .name_flat="F0 " ,.frequency=F0},  {.name_sharp="Fs0", .name_flat="Gb0", .frequency=Gb0}, {.name_sharp="G0 ", .name_flat="G0 ", .frequency=G0},  {.name_sharp="Gs0", .name_flat="Ab0", .frequency=Ab0}, {.name_sharp="A0 ", .name_flat="A0 ", .frequency=A0},  {.name_sharp="As0", .name_flat="Bb0", .frequency=Bb0}, {.name_sharp="B0 ", .name_flat="B0 ", .frequency=B0},
    {.name_sharp="C1 ", .name_flat="C1 ", .frequency=C1},  {.name_sharp="Cs1", .name_flat="Db1", .frequency=Db1}, {.name_sharp="D1 ", .name_flat="D1 ", D1},  {.name_sharp="Ds1",  .name_flat="Eb1", .frequency=Eb1}, {.name_sharp="E1 ", .name_flat="E1 ", E1},  {.name_sharp="F1 ", .name_flat="F1 " ,.frequency=F1},  {.name_sharp="Fs1", .name_flat="Gb1", .frequency=Gb1}, {.name_sharp="G1 ", .name_flat="G1 ", .frequency=G1},  {.name_sharp="Gs1", .name_flat="Ab1", .frequency=Ab1}, {.name_sharp="A1 ", .name_flat="A1 ", .frequency=A1},  {.name_sharp="As1", .name_flat="Bb1", .frequency=Bb1}, {.name_sharp="B1 ", .name_flat="B1 ", .frequency=B1},
    {.name_sharp="C2 ", .name_flat="C2 ", .frequency=C2},  {.name_sharp="Cs2", .name_flat="Db2", .frequency=Db2}, {.name_sharp="D2 ", .name_flat="D2 ", D2},  {.name_sharp="Ds2",  .name_flat="Eb2", .frequency=Eb2}, {.name_sharp="E2 ", .name_flat="E2 ", E2},  {.name_sharp="F2 ", .name_flat="F2 " ,.frequency=F2},  {.name_sharp="Fs2", .name_flat="Gb2", .frequency=Gb2}, {.name_sharp="G2 ", .name_flat="G2 ", .frequency=G2},  {.name_sharp="Gs2", .name_flat="Ab2", .frequency=Ab2}, {.name_sharp="A2 ", .name_flat="A2 ", .frequency=A2},  {.name_sharp="As2", .name_flat="Bb2", .frequency=Bb2}, {.name_sharp="B2 ", .name_flat="B2 ", .frequency=B2},
    {.name_sharp="C3 ", .name_flat="C3 ", .frequency=C3},  {.name_sharp="Cs3", .name_flat="Db3", .frequency=Db3}, {.name_sharp="D3 ", .name_flat="D3 ", D3},  {.name_sharp="Ds3",  .name_flat="Eb3", .frequency=Eb3}, {.name_sharp="E3 ", .name_flat="E3 ", E3},  {.name_sharp="F3 ", .name_flat="F3 " ,.frequency=F3},  {.name_sharp="Fs3", .name_flat="Gb3", .frequency=Gb3}, {.name_sharp="G3 ", .name_flat="G3 ", .frequency=G3},  {.name_sharp="Gs3", .name_flat="Ab3", .frequency=Ab3}, {.name_sharp="A3 ", .name_flat="A3 ", .frequency=A3},  {.name_sharp="As3", .name_flat="Bb3", .frequency=Bb3}, {.name_sharp="B3 ", .name_flat="B3 ", .frequency=B3},
    {.name_sharp="C4 ", .name_flat="C4 ", .frequency=C4},  {.name_sharp="Cs4", .name_flat="Db4", .frequency=Db4}, {.name_sharp="D4 ", .name_flat="D4 ", D4},  {.name_sharp="Ds4",  .name_flat="Eb4", .frequency=Eb4}, {.name_sharp="E4 ", .name_flat="E4 ", E4},  {.name_sharp="F4 ", .name_flat="F4 " ,.frequency=F4},  {.name_sharp="Fs4", .name_flat="Gb4", .frequency=Gb4}, {.name_sharp="G4 ", .name_flat="G4 ", .frequency=G4},  {.name_sharp="Gs4", .name_flat="Ab4", .frequency=Ab4}, {.name_sharp="A4 ", .name_flat="A4 ", .frequency=A4},  {.name_sharp="As4", .name_flat="Bb4", .frequency=Bb4}, {.name_sharp="B4 ", .name_flat="B4 ", .frequency=B4},
    {.name_sharp="C5 ", .name_flat="C5 ", .frequency=C5},  {.name_sharp="Cs5", .name_flat="Db5", .frequency=Db5}, {.name_sharp="D5 ", .name_flat="D5 ", D5},  {.name_sharp="Ds5",  .name_flat="Eb5", .frequency=Eb5}, {.name_sharp="E5 ", .name_flat="E5 ", E5},  {.name_sharp="F5 ", .name_flat="F5 " ,.frequency=F5},  {.name_sharp="Fs5", .name_flat="Gb5", .frequency=Gb5}, {.name_sharp="G5 ", .name_flat="G5 ", .frequency=G5},  {.name_sharp="Gs5", .name_flat="Ab5", .frequency=Ab5}, {.name_sharp="A5 ", .name_flat="A5 ", .frequency=A5},  {.name_sharp="As5", .name_flat="Bb5", .frequency=Bb5}, {.name_sharp="B5 ", .name_flat="B5 ", .frequency=B5}, 
    {.name_sharp="C6 ", .name_flat="C6 ", .frequency=C6},  {.name_sharp="Cs6", .name_flat="Db6", .frequency=Db6}, {.name_sharp="D6 ", .name_flat="D6 ", D6},  {.name_sharp="Ds6",  .name_flat="Eb6", .frequency=Eb6}, {.name_sharp="E6 ", .name_flat="E6 ", E6},  {.name_sharp="F6 ", .name_flat="F6 " ,.frequency=F6},  {.name_sharp="Fs6", .name_flat="Gb6", .frequency=Gb6}, {.name_sharp="G6 ", .name_flat="G6 ", .frequency=G6},  {.name_sharp="Gs6", .name_flat="Ab6", .frequency=Ab6}, {.name_sharp="A6 ", .name_flat="A6 ", .frequency=A6},  {.name_sharp="As6", .name_flat="Bb6", .frequency=Bb6}, {.name_sharp="B6 ", .name_flat="B6 ", .frequency=B6},
    {.name_sharp="C7 ", .name_flat="C7 ", .frequency=C7},  {.name_sharp="Cs7", .name_flat="Db7", .frequency=Db7}, {.name_sharp="D7 ", .name_flat="D7 ", D7},  {.name_sharp="Ds7",  .name_flat="Eb7", .frequency=Eb7}, {.name_sharp="E7 ", .name_flat="E7 ", E7},  {.name_sharp="F7 ", .name_flat="F7 " ,.frequency=F7},  {.name_sharp="Fs7", .name_flat="Gb7", .frequency=Gb7}, {.name_sharp="G7 ", .name_flat="G7 ", .frequency=G7},  {.name_sharp="Gs7", .name_flat="Ab7", .frequency=Ab7}, {.name_sharp="A7 ", .name_flat="A7 ", .frequency=A7},  {.name_sharp="As7", .name_flat="Bb7", .frequency=Bb7}, {.name_sharp="B7 ", .name_flat="B7 ", .frequency=B7},
    {.name_sharp="C8 ", .name_flat="C8 ", .frequency=C8},  {.name_sharp="Cs8", .name_flat="Db8", .frequency=Db8}, {.name_sharp="D8 ", .name_flat="D8 ", D8},  {.name_sharp="Ds8",  .name_flat="Eb8", .frequency=Eb8}, {.name_sharp="E8 ", .name_flat="E8 ", E8},  {.name_sharp="F8 ", .name_flat="F8 " ,.frequency=F8},  {.name_sharp="Fs8", .name_flat="Gb8", .frequency=Gb8}, {.name_sharp="G8 ", .name_flat="G8 ", .frequency=G8},  {.name_sharp="Gs8", .name_flat="Ab8", .frequency=Ab8}, {.name_sharp="A8 ", .name_flat="A8 ", .frequency=A8},  {.name_sharp="As8", .name_flat="Bb8", .frequency=Bb8}, {.name_sharp="B8 ", .name_flat="B8 ", .frequency=B8},
};

static curve_position str_pos = {
    .str_x_offset = 2,
    .str_y_offset = 10,

    .graph_x_offset = 2,
    .graph_y_offset = 24,

    .graph_white_x_offset = 0,
    .graph_white_y_offset = 0,
    .graph_white_width = 10,
    .greph_white_high = 38,

    .graph_black_x_offset = 6,
    .graph_black_y_offset = -4,
    .graph_black_width = 8,
    .greph_black_high = 30,

    .sheet_x_offset = 90,
    .sheet_y_offset = 30,
    .sheet_x_width = 30,
    .sheet_y_high = 5,
    .sheet_F_clef_x_offset = 75,
    .sheet_F_clef_y_offset = 30,
    .sheet_c_note_x_offset = 15,
    .sheet_c_note_y_offset = 20,

    .freqent  = 440.0f,
    .freq_max = 1000.0f,
    .freq_min = 0.0f,

    .note_index = STANDARD_A_INDEX,
    .note_max   = NOTE_MAX,
    .note_min   = NOTE_MIN,

    .volume  = 1.0f,
    .vol_max = 60.0f,
    .vol_min = 0.0f,
};

static bool is_white_note(uint8_t semitone, uint8_t id) {
    switch(semitone) {
    case 0:
        if(id == 0) return true;
        break;
    case 2:
        if(id == 1) return true;
        break;
    case 4:
        if(id == 2) return true;
        break;
    case 5:
        if(id == 3) return true;
        break;
    case 7:
        if(id == 4) return true;
        break;
    case 9:
        if(id == 5) return true;
        break;
    case 11:
        if(id == 6) return true;
        break;
    default:
        break;
    }

    return false;
}

static bool is_black_note(uint8_t semitone, uint8_t id) {
    switch(semitone) {
    case 1:
        if(id == 0) return true;
        break;
    case 3:
        if(id == 1) return true;
        break;
    case 6:
        if(id == 3) return true;
        break;
    case 8:
        if(id == 4) return true;
        break;
    case 10:
        if(id == 5) return true;
        break;
    default:
        break;
    }

    return false;
}

void draw_note(Canvas *canvas)
{
    UNUSED(canvas);
    
    uint8_t x_pos = str_pos.graph_x_offset;
    uint8_t y_pos = str_pos.graph_y_offset;
    const uint8_t white_x = str_pos.graph_white_x_offset;
    const uint8_t white_y = str_pos.graph_white_y_offset;
    const uint8_t white_w = str_pos.graph_white_width;
    const uint8_t white_h = str_pos.greph_white_high;

    const int8_t black_x = str_pos.graph_black_x_offset;
    const int8_t black_y = str_pos.graph_black_y_offset;
    const uint8_t black_w = str_pos.graph_black_width;
    const uint8_t black_h = str_pos.greph_black_high;

    // white keys
    for(size_t i = 0; i < 7; i++) {
        if(is_white_note(str_pos.note_index%12, i)) {
            canvas_draw_box(canvas, x_pos + white_w * i + white_x, y_pos + white_y, white_w + 1, white_h);
        } else {
            canvas_draw_frame(canvas, x_pos + white_w * i + white_x, y_pos + white_y, white_w + 1, white_h);
        }
    }
    // black keys
    for(size_t i = 0; i < 7; i++) {
        if(i != 2 && i != 6) {
            canvas_set_color(canvas, ColorWhite);
            canvas_draw_box(canvas, x_pos + white_w * i + black_x, y_pos + black_y, black_w + 1, black_h);
            canvas_set_color(canvas, ColorBlack);
            if(is_black_note(str_pos.note_index%12, i)) {
                canvas_draw_box(canvas, x_pos + white_w * i + black_x, y_pos + black_y, black_w + 1, black_h);
            } else {
                canvas_draw_frame(canvas, x_pos + white_w * i + black_x, y_pos + black_y, black_w + 1, black_h);
            }
        }
    }
}

//draw_note_freq and note_name
void draw_string(Canvas *canvas)
{
    double cur_freq = note[str_pos.note_index].frequency;

    snprintf(str_pos.str, sizeof(str_pos.str), "Vol=%.1f", str_pos.volume);
    canvas_draw_str(canvas, str_pos.str_x_offset, str_pos.str_y_offset, str_pos.str);
    //chose flat or sharp
    if(str_pos.freqent >= cur_freq)
    {
        snprintf(str_pos.str, sizeof(str_pos.str), "freq=%.1f, Note=%s", cur_freq, note[str_pos.note_index].name_flat);
    }
    else
    {
        snprintf(str_pos.str, sizeof(str_pos.str), "freq=%.1f, Note=%s", cur_freq, note[str_pos.note_index].name_sharp);
    }
    canvas_draw_str(canvas, str_pos.str_x_offset, str_pos.str_y_offset + FONT_Y_PIX, str_pos.str);
}

//draw line and clef and note
void draw_sheet(Canvas *canvas)
{
    //draw sheet line
    for(int i=0;i<5;i++)
    {
        int16_t x_begin_at = str_pos.sheet_x_offset;
        int16_t x_end_at = str_pos.sheet_x_offset + str_pos.sheet_x_width;
        int16_t y_begin_at = str_pos.sheet_y_offset + i * str_pos.sheet_y_high;
        int16_t y_end_at = y_begin_at;

        canvas_draw_line(canvas, x_begin_at, y_begin_at, x_end_at, y_end_at);
    }

    //draw clef
    //[TO-DO]
    canvas_draw_box(canvas, str_pos.sheet_F_clef_x_offset, str_pos.sheet_F_clef_y_offset, 15, 20);
    //canvas_draw_icon(canvas, str_pos.sheet_F_clef_x_offset, str_pos.sheet_F_clef_y_offset, &I_Battery_26x8);

    //draw note
    if(is_white_note(str_pos.note_index % 12, (str_pos.note_index % 12+1)/2)) {
        int16_t x_begin_at = str_pos.sheet_x_offset + str_pos.sheet_x_width/2;
        int16_t y_begin_at = str_pos.sheet_y_offset + str_pos.sheet_y_high*4 - (str_pos.note_index%12+1)/2 * str_pos.sheet_y_high / 2;
        FURI_LOG_W("Fjone", "x_begin_at=%d, y_begin_at=%d", x_begin_at, y_begin_at);
        canvas_draw_circle(canvas, x_begin_at, y_begin_at, str_pos.sheet_y_high/2);
    }

}

void draw_callback(Canvas *canvas, void *ctx)
{
    FuriMutex *ctx_mutex = (FuriMutex *)ctx;
    furi_check(furi_mutex_acquire(ctx_mutex, FuriWaitForever) == FuriStatusOk);
    canvas_draw_frame(canvas, 0, 0, 128, 64);
    draw_string(canvas);
    draw_note(canvas);
    draw_sheet(canvas);
    furi_mutex_release(ctx_mutex);
}

// 通过这个函数将 InputEvent 放到 event_queue 中
void input_callback(InputEvent *input, void *ctx)
{
    FuriMessageQueue *event_queue = (FuriMessageQueue *)ctx;

    furi_message_queue_put(event_queue, input, 1000);
}

void app_alloc()
{
    // 这个看起来是添加锁
    model_mutex = furi_mutex_alloc(FuriMutexTypeNormal);
    view_port   = view_port_alloc();
    gui         = furi_record_open("gui");
    // 这个函数注册 event_queue
    event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    view_port_draw_callback_set(view_port, draw_callback, model_mutex);
    view_port_input_callback_set(view_port, input_callback, event_queue);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    return;
}

void app_free()
{
    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port); // Removes our ViewPort from the Gui
    furi_record_close("gui");             // Closes the gui record
    view_port_free(view_port);            // Frees memory allocated by view_port_alloc
    // 这个函数释放 event_queue
    furi_message_queue_free(event_queue);

    // 看起来是释放锁
    furi_mutex_free(model_mutex);

    // 停止蜂鸣器
    if (furi_hal_speaker_is_mine())
    {
        furi_hal_speaker_stop();
        furi_hal_speaker_release();
    }

    return;
}

double fix_max_double(double *input, double input_max)
{
    if (*input > input_max)
    {
        *input = input_max;
    }
    return *input;
}

double fix_min_double(double *input, int input_min)
{
    if (*input < input_min)
    {
        *input = input_min;
    }
    return *input;
}

int fix_max(int16_t *input, int16_t input_min, int16_t input_max)
{
    if (*input > input_max)
    {
        *input = input_min;
    }
    return *input;
}

int fix_min(int16_t *input, int16_t input_min, int16_t input_max)
{
    if (*input < input_min)
    {
        *input = input_max;
    }
    return *input;
}

int32_t app_main(void *p)
{
    UNUSED(p);
    InputEvent event;

    app_alloc();

    for (bool processing = true; processing;)
    {
        // 通过这个函数将 InputEvent 从 event_queue 中取出来, 并判断 event.key 来对每一个按键进行配置
        FuriStatus status = furi_message_queue_get(event_queue, &event, 100);

        furi_check(furi_mutex_acquire(model_mutex, FuriWaitForever) == FuriStatusOk);

        if (status == FuriStatusOk)
        {
            if (event.type == InputTypePress)
            {
                switch (event.key)
                {
                    case InputKeyBack:
                        processing = false;
                        break;
                    case InputKeyUp:
                        str_pos.volume += (double)0.1f;
                        fix_max_double(&str_pos.volume, str_pos.vol_max);
                        break;
                    case InputKeyDown:
                        str_pos.volume -= (double)0.1f;
                        fix_min_double(&str_pos.volume, str_pos.vol_min);
                        break;
                    case InputKeyLeft:
                        str_pos.freqent = note[str_pos.note_index].frequency;
                        str_pos.note_index -= 1;
                        fix_min(&str_pos.note_index, str_pos.note_min, str_pos.note_max);
                        break;
                    case InputKeyRight:
                        str_pos.freqent = note[str_pos.note_index].frequency;
                        str_pos.note_index += 1;
                        fix_max(&str_pos.note_index, str_pos.note_min, str_pos.note_max);
                        break;
                    case InputKeyOk:

                        if (furi_hal_speaker_is_mine() || furi_hal_speaker_acquire(1000))
                        {
                            furi_hal_speaker_start((float)note[str_pos.note_index].frequency, (float)str_pos.volume);
                        }
                        break;
                    default:
                        break;
                }
            }
            else if (event.type == InputTypeRelease)
            {
                if (furi_hal_speaker_is_mine())
                {
                    furi_hal_speaker_stop();
                    furi_hal_speaker_release();
                }
            }
            else if (event.type == InputTypeRepeat)
            {
                switch (event.key)
                {
                    case InputKeyBack:

                        processing = false;
                        break;
                    case InputKeyUp:
                        str_pos.volume += (double)0.1f;
                        fix_max_double(&str_pos.volume, str_pos.vol_max);
                        break;
                    case InputKeyDown:
                        str_pos.volume -= (double)0.1f;
                        fix_min_double(&str_pos.volume, str_pos.vol_min);
                        break;
                    case InputKeyLeft:
                        str_pos.freqent = note[str_pos.note_index].frequency;//get last frequency
                        str_pos.note_index -= 1;
                        fix_min(&str_pos.note_index, str_pos.note_min, str_pos.note_max);
                        break;
                    case InputKeyRight:
                        str_pos.freqent = note[str_pos.note_index].frequency;//get last frequency
                        str_pos.note_index += 1;
                        fix_max(&str_pos.note_index, str_pos.note_min, str_pos.note_max);
                        break;
                    default:
                        break;
                }
            }
        }

        furi_mutex_release(model_mutex);
        view_port_update(view_port); // signals our draw callback
    }

    app_free();
    return 0;
}
